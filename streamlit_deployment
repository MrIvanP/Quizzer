import streamlit as st
import json
import os
import random

DATA_FILE = "vocab_data.json"

def load_data():
    if not os.path.exists(DATA_FILE):
        return {}
    with open(DATA_FILE, "r") as f:
        return json.load(f)

def save_data(data):
    with open(DATA_FILE, "w") as f:
        json.dump(data, f, indent=4)

# Helper functions for UI

def select_course(data, key="course"):
    courses = list(data.keys())
    if not courses:
        st.warning("No courses found. Please add one.")
        return None
    return st.selectbox("Select Course", courses, key=key)

def select_book(data, course, key="book"):
    books = list(data.get(course, {}).keys())
    if not books:
        st.warning("No books found in this course. Please add one.")
        return None
    return st.selectbox("Select Book", books, key=key)

def add_course(data):
    with st.expander("Add New Course"):
        new_course = st.text_input("Course Name", key="new_course")
        if st.button("Add Course"):
            if not new_course.strip():
                st.error("Course name cannot be empty.")
            elif new_course in data:
                st.error("Course already exists.")
            else:
                data[new_course] = {}
                save_data(data)
                st.success(f"Course '{new_course}' added.")
                st.experimental_rerun()

def add_book(data, course):
    if course:
        with st.expander("Add New Book"):
            new_book = st.text_input("Book Name", key="new_book")
            if st.button("Add Book"):
                if not new_book.strip():
                    st.error("Book name cannot be empty.")
                elif new_book in data[course]:
                    st.error("Book already exists in this course.")
                else:
                    data[course][new_book] = {}
                    save_data(data)
                    st.success(f"Book '{new_book}' added to course '{course}'.")
                    st.experimental_rerun()

def add_term(data, course, book):
    if course and book:
        with st.expander("Add New Term"):
            new_term = st.text_input("Term", key="new_term")
            new_def = st.text_area("Definition", key="new_def")
            if st.button("Add Term"):
                if not new_term.strip() or not new_def.strip():
                    st.error("Term and definition cannot be empty.")
                elif new_term in data[course][book]:
                    st.error("Term already exists in this book.")
                else:
                    data[course][book][new_term] = new_def
                    save_data(data)
                    st.success(f"Term '{new_term}' added to book '{book}'.")
                    st.experimental_rerun()

def rename_key(d, old_key, new_key):
    d[new_key] = d.pop(old_key)

def manage_items(data, course, book):
    st.markdown("### Manage Items")
    if course:
        st.subheader(f"Course: {course}")
        # Rename or delete course
        col1, col2 = st.columns(2)
        with col1:
            new_course_name = st.text_input("Rename Course", value=course)
            if st.button("Rename Course"):
                if new_course_name and new_course_name != course:
                    if new_course_name in data:
                        st.error("Course name already exists.")
                    else:
                        rename_key(data, course, new_course_name)
                        save_data(data)
                        st.success("Course renamed.")
                        st.experimental_rerun()
        with col2:
            if st.button("Delete Course"):
                if st.confirm("Are you sure you want to delete this course and all its content?"):
                    data.pop(course)
                    save_data(data)
                    st.success("Course deleted.")
                    st.experimental_rerun()

    if course and book:
        st.subheader(f"Book: {book}")
        col1, col2 = st.columns(2)
        with col1:
            new_book_name = st.text_input("Rename Book", value=book)
            if st.button("Rename Book"):
                if new_book_name and new_book_name != book:
                    if new_book_name in data[course]:
                        st.error("Book name already exists in this course.")
                    else:
                        rename_key(data[course], book, new_book_name)
                        save_data(data)
                        st.success("Book renamed.")
                        st.experimental_rerun()
        with col2:
            if st.button("Delete Book"):
                if st.confirm("Are you sure you want to delete this book and all its terms?"):
                    data[course].pop(book)
                    save_data(data)
                    st.success("Book deleted.")
                    st.experimental_rerun()

    if course and book:
        terms = list(data[course][book].keys())
        if terms:
            st.subheader("Terms")
            for term in terms:
                col1, col2 = st.columns([3,1])
                with col1:
                    new_term_name = st.text_input(f"Rename Term '{term}'", value=term, key=f"rename_{term}")
                with col2:
                    if st.button(f"Delete Term '{term}'", key=f"delete_{term}"):
                        if st.confirm(f"Delete term '{term}'?"):
                            data[course][book].pop(term)
                            save_data(data)
                            st.success(f"Term '{term}' deleted.")
                            st.experimental_rerun()
                if new_term_name != term:
                    if new_term_name in data[course][book]:
                        st.error(f"Term '{new_term_name}' already exists.")
                    elif new_term_name.strip():
                        # Rename term
                        data[course][book][new_term_name] = data[course][book].pop(term)
                        save_data(data)
                        st.success(f"Term '{term}' renamed to '{new_term_name}'.")
                        st.experimental_rerun()
        else:
            st.info("No terms in this book yet.")

def quiz(data, course, book):
    st.header("Start Quiz")
    if not course or not book:
        st.warning("Please select a course and a book first.")
        return

    terms = list(data[course][book].items())
    if len(terms) < 2:
        st.info("Need at least 2 terms to start a quiz.")
        return

    all_terms = [term for term, _ in terms]

    subset_mode = st.radio("Quiz Mode", ["All Terms", "Custom Subset"])
    if subset_mode == "Custom Subset":
        selected_terms = st.multiselect("Select terms to quiz", all_terms, default=all_terms)
    else:
        selected_terms = all_terms

    # Prepare quiz data
    quiz_terms = [(term, data[course][book][term]) for term in selected_terms]

    if "quiz_state" not in st.session_state:
        st.session_state.quiz_state = {
            "terms": random.sample(quiz_terms, len(quiz_terms)),
            "index": 0,
            "score": 0,
            "show_answer": False,
            "selected_answer": None,
            "quiz_active": False
        }

    state = st.session_state.quiz_state

    def reset_quiz():
        state["terms"] = random.sample(quiz_terms, len(quiz_terms))
        state["index"] = 0
        state["score"] = 0
        state["show_answer"] = False
        state["selected_answer"] = None
        state["quiz_active"] = True

    if not state["quiz_active"]:
        if st.button("Start Quiz"):
            reset_quiz()
    else:
        term, correct_def = state["terms"][state["index"]]

        st.markdown(f"### What is the definition of:\n\n**{term}**")

        # Build options with 3 random incorrect defs + 1 correct def
        other_defs = [d for t, d in quiz_terms if d != correct_def]
        options = random.sample(other_defs, min(3, len(other_defs))) + [correct_def]
        random.shuffle(options)

        choice = st.radio("Choose an answer:", options, index=options.index(state["selected_answer"]) if state["selected_answer"] in options else 0, key="answer_choice")

        if not state["show_answer"]:
            if st.button("Submit"):
                state["selected_answer"] = choice
                state["show_answer"] = True
                if choice == correct_def:
                    state["score"] += 1
        else:
            if choice == correct_def:
                st.success("Correct! ðŸŽ‰")
            else:
                st.error(f"Incorrect! The correct answer is:\n\n{correct_def}")

            if st.button("Next"):
                state["index"] += 1
                state["show_answer"] = False
                state["selected_answer"] = None
                if state["index"] >= len(state["terms"]):
                    st.success(f"Quiz completed! Your score: {state['score']}/{len(state['terms'])}")
                    state["quiz_active"] = False
                    state["index"] = 0

        if st.button("Exit Quiz"):
            if st.confirm("Are you sure you want to exit the quiz?"):
                state["quiz_active"] = False
                state["index"] = 0

def main():
    st.title("Vocabulary Tree Quiz App (Streamlit)")

    data = load_data()

    # Sidebar for navigation & management
    st.sidebar.header("Vocabulary Management")

    add_course(data)

    course = select_course(data)
    if course:
        add_book(data, course)
        book = select_book(data, course)
        if book:
            add_term(data, course, book)
        else:
            book = None
    else:
        book = None

    st.sidebar.markdown("---")
    if course and book:
        manage_items(data, course, book)

    st.sidebar.markdown("---")
    st.sidebar.markdown("Â© 2025 Vocabulary App")

    st.sidebar.markdown("## Start Quiz")
    quiz(data, course, book)

if __name__ == "__main__":
    main()
