import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
import json
import os
import random

DATA_FILE = "vocab_data.json"

# Initialize data if file doesn't exist
if not os.path.exists(DATA_FILE):
    with open(DATA_FILE, "w") as f:
        json.dump({}, f)

def load_data():
    if not os.path.exists(DATA_FILE):
        return {}
    try:
        with open(DATA_FILE, "r") as f:
            return json.load(f)
    except json.JSONDecodeError:
        messagebox.showerror("Data Error", "Failed to load data file. Resetting data.")
        return {}

def save_data(data):
    try:
        with open(DATA_FILE, "w") as f:
            json.dump(data, f, indent=4)
    except Exception as e:
        messagebox.showerror("Save Error", f"Failed to save data: {e}")

# ---------- NEW DIALOG FOR LONG DEFINITIONS ----------
class DefinitionDialog(simpledialog.Dialog):
    def __init__(self, parent, title, initial_text=""):
        self.initial_text = initial_text
        self.result = None
        super().__init__(parent, title)

    def body(self, master):
        tk.Label(master, text="Enter definition:").pack(anchor="w")

        self.text = tk.Text(master, wrap="word", width=80, height=10)  # ~80 chars wide
        self.text.pack(fill="both", expand=True)
        self.text.insert("1.0", self.initial_text)

        return self.text

    def apply(self):
        self.result = self.text.get("1.0", "end-1c").strip()
# -----------------------------------------------------

class VocabApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Vocabulary Tree Quiz App")
        self.data = load_data()

        self.setup_styles()
        self.setup_ui()
        self.build_tree()

    def on_double_click(self, event):
        item = self.tree.selection()
        if not item:
            return
        course, book, term = self.get_selected_path()
        if course and book and term:
            self.view_edit_definition()

    def setup_styles(self):
        self.style = ttk.Style()
        self.style.configure("Quiz.TRadiobutton", background="white")
        self.style.configure("Correct.TRadiobutton", background="pale green")
        self.style.configure("Incorrect.TRadiobutton", background="tomato")

    def setup_ui(self):
        self.tree = ttk.Treeview(self.root)
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.LEFT, fill=tk.Y)

        btn_frame = tk.Frame(self.root)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)

        ttk.Button(btn_frame, text="Add Course", command=self.add_course).pack(pady=5, fill='x')
        ttk.Button(btn_frame, text="Add Book", command=self.add_book).pack(pady=5, fill='x')
        ttk.Button(btn_frame, text="Add Term", command=self.add_term).pack(pady=5, fill='x')
        ttk.Button(btn_frame, text="Search Term", command=self.search_terms).pack(pady=5, fill='x')
        ttk.Button(btn_frame, text="Start Quiz", command=self.start_quiz).pack(pady=10, fill='x')

        # Right-click menu
        self.menu = tk.Menu(self.root, tearoff=0)
        self.menu.add_command(label="View/Edit Definition", command=self.view_edit_definition)
        self.menu.add_separator()
        self.menu.add_command(label="Add Book", command=self.add_book)
        self.menu.add_command(label="Add Term", command=self.add_term)
        self.menu.add_separator()
        self.menu.add_command(label="Rename", command=self.rename_item)
        self.menu.add_command(label="Delete", command=self.delete_item)

        self.tree.bind("<Button-3>", self.show_context_menu)
        self.tree.bind("<Double-1>", self.on_double_click)

    def build_tree(self):
        self.tree.delete(*self.tree.get_children())
        for course in self.data:
            course_id = self.tree.insert("", "end", text=course, open=True)
            for book in self.data[course]:
                book_id = self.tree.insert(course_id, "end", text=book, open=False)
                for term in self.data[course][book]:
                    self.tree.insert(book_id, "end", text=term, open=False)

    def show_context_menu(self, event):
        selected_item = self.tree.identify_row(event.y)
        if selected_item:
            self.tree.selection_set(selected_item)
            self.menu.post(event.x_root, event.y_root)

    def get_selected_path(self):
        selected = self.tree.selection()
        if not selected:
            return None, None, None

        item = selected[0]
        parent = self.tree.parent(item)
        grandparent = self.tree.parent(parent) if parent else None

        if grandparent:  # term level
            course = self.tree.item(grandparent, "text")
            book = self.tree.item(parent, "text")
            term = self.tree.item(item, "text")
            return course, book, term
        elif parent:  # book level
            course = self.tree.item(parent, "text")
            book = self.tree.item(item, "text")
            return course, book, None
        else:  # course level
            course = self.tree.item(item, "text")
            return course, None, None

    def get_item_depth(self, item):
        depth = 0
        current = item
        while self.tree.parent(current):
            depth += 1
            current = self.tree.parent(current)
        return depth

    def add_course(self):
        course = simpledialog.askstring("New Course", "Enter course name:")
        if not course:
            return
        if course in self.data:
            messagebox.showwarning("Duplicate", "Course already exists.")
            return
        self.data[course] = {}
        save_data(self.data)
        self.build_tree()

    def add_book(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("Select Course", "Select a course or book to add a book.")
            return

        item = selected[0]
        depth = self.get_item_depth(item)

        if depth == 0:
            course = self.tree.item(item, "text")
        elif depth == 1:
            course = self.tree.item(self.tree.parent(item), "text")
        else:
            messagebox.showwarning("Invalid", "Select a course or book to add a book.")
            return

        book = simpledialog.askstring("New Book", "Enter book name:")
        if not book:
            return
        if book in self.data[course]:
            messagebox.showwarning("Duplicate", "Book already exists in this course.")
            return
        self.data[course][book] = {}
        save_data(self.data)
        self.build_tree()

    def add_term(self):
        course, book, _ = self.get_selected_path()
        if not course or not book:
            messagebox.showwarning("Select Book", "Select a book to add a term.")
            return

        term = simpledialog.askstring("New Term", "Enter term:")
        if not term:
            return
        if term in self.data[course][book]:
            messagebox.showwarning("Duplicate", "Term already exists.")
            return

        # Use large dialog for definition
        definition = DefinitionDialog(self.root, f"Definition for '{term}'").result
        if not definition:
            return

        self.data[course][book][term] = definition
        save_data(self.data)
        self.build_tree()

    def view_edit_definition(self):
        course, book, term = self.get_selected_path()
        if not course or not book or not term:
            messagebox.showwarning("Select Term", "Select a term to view or edit its definition.")
            return

        current_def = self.data[course][book].get(term, "")
        new_def = DefinitionDialog(self.root, f"Definition for '{term}'", initial_text=current_def).result
        if new_def is not None:
            self.data[course][book][term] = new_def
            save_data(self.data)
            messagebox.showinfo("Updated", f"Definition for '{term}' updated.")

    def rename_item(self):
        selected = self.tree.selection()
        if not selected:
            return
        item = selected[0]
        old_name = self.tree.item(item, "text")
        parent = self.tree.parent(item)
        new_name = simpledialog.askstring("Rename", f"Rename '{old_name}' to:")
        if not new_name or new_name == old_name:
            return

        depth = self.get_item_depth(item)

        try:
            if depth == 0:  # Course
                if new_name in self.data:
                    messagebox.showerror("Error", "Course already exists.")
                    return
                self.data[new_name] = self.data.pop(old_name)

            elif depth == 1:  # Book
                course = self.tree.item(parent, "text")
                if new_name in self.data[course]:
                    messagebox.showerror("Error", "Book already exists.")
                    return
                self.data[course][new_name] = self.data[course].pop(old_name)

            elif depth == 2:  # Term
                book = self.tree.item(parent, "text")
                course = self.tree.item(self.tree.parent(parent), "text")
                if new_name in self.data[course][book]:
                    messagebox.showerror("Error", "Term already exists.")
                    return
                self.data[course][book][new_name] = self.data[course][book].pop(old_name)

            save_data(self.data)
            self.build_tree()
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def delete_item(self):
        selected = self.tree.selection()
        if not selected:
            return
        item = selected[0]
        name = self.tree.item(item, "text")
        parent = self.tree.parent(item)

        depth = self.get_item_depth(item)

        confirm = messagebox.askyesno("Delete", f"Are you sure you want to delete '{name}'?")
        if not confirm:
            return

        try:
            if depth == 0:  # Course
                self.data.pop(name)
            elif depth == 1:  # Book
                course = self.tree.item(parent, "text")
                self.data[course].pop(name)
            elif depth == 2:  # Term
                book = self.tree.item(parent, "text")
                course = self.tree.item(self.tree.parent(parent), "text")
                self.data[course][book].pop(name)

            save_data(self.data)
            self.build_tree()
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def start_quiz(self):
        course, book, _ = self.get_selected_path()
        if not course or not book:
            messagebox.showwarning("Select Book", "Select a book to start quiz.")
            return

        all_terms = list(self.data[course][book].items())
        if len(all_terms) < 2:
            messagebox.showinfo("Not enough terms", "You need at least 2 terms for a quiz.")
            return

        choice = messagebox.askquestion(
            "Quiz Scope",
            "Would you like to be quizzed on all terms in this book?\n\n"
            "Select 'No' to choose a custom subset."
        )

        if choice == "no":
            dialog = TermSelectionDialog(self.root, all_terms)
            terms = dialog.selected_terms
            if not terms or len(terms) < 2:
                messagebox.showinfo("Not enough terms", "You need at least 2 terms for a quiz.")
                return
        else:
            terms = all_terms

        QuizWindow(self.root, terms)

    def search_terms(self):
        query = simpledialog.askstring("Search Term", "Enter part of a term to search:")
        if not query:
            return

        query = query.lower()
        results = []
        for course, books in self.data.items():
            for book, terms in books.items():
                for term, definition in terms.items():
                    if query in term.lower():
                        results.append((course, book, term, definition))

        if not results:
            messagebox.showinfo("No Results", f"No terms found matching '{query}'.")
            return

        SearchWindow(self.root, results, self.data)
        save_data(self.data)

class TermSelectionDialog(simpledialog.Dialog):
    def __init__(self, parent, terms):
        self.terms = terms
        self.selected_terms = []
        super().__init__(parent, title="Select Terms for Quiz")

    def body(self, frame):
        tk.Label(frame, text="Select terms to include in quiz:").pack(anchor="w")

        self.vars = []
        canvas = tk.Canvas(frame)
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
        self.check_frame = tk.Frame(canvas)

        self.check_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=self.check_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set, height=200)

        canvas.pack(side=tk.LEFT, fill="both", expand=True)
        scrollbar.pack(side=tk.RIGHT, fill="y")

        for term, definition in self.terms:
            var = tk.BooleanVar(value=True)
            cb = tk.Checkbutton(self.check_frame, text=term, variable=var)
            cb.pack(anchor="w")
            self.vars.append((var, term, definition))

        return frame  # initial focus

    def apply(self):
        self.selected_terms = [(term, definition) for var, term, definition in self.vars if var.get()]

class SearchWindow:
    def __init__(self, master, results, data):
        self.top = tk.Toplevel(master)
        self.top.title("Search Results")
        self.data = data
        self.results = results

        tk.Label(self.top, text="Search Results:", font=("Arial", 12, "bold")).pack(pady=5)

        self.listbox = tk.Listbox(self.top, width=60, height=15)
        self.listbox.pack(padx=10, pady=5)

        for course, book, term, definition in results:
            self.listbox.insert(tk.END, f"{course} > {book} > {term}")

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(pady=5)

        tk.Button(btn_frame, text="View/Edit Definition", command=self.edit_selected).pack(side=tk.LEFT, padx=5)
        tk.Button(btn_frame, text="Close", command=self.top.destroy).pack(side=tk.LEFT, padx=5)

    def edit_selected(self):
        selection = self.listbox.curselection()
        if not selection:
            messagebox.showwarning("Select Item", "Please select a term to view/edit.")
            return

        index = selection[0]
        course, book, term, definition = self.results[index]

        new_def = DefinitionDialog(self.top, f"Edit Definition for '{term}'", initial_text=definition).result

        if new_def is not None:
            self.data[course][book][term] = new_def
            messagebox.showinfo("Updated", f"Definition for '{term}' updated.")

class QuizWindow:
    def __init__(self, master, terms):
        self.top = tk.Toplevel(master)
        self.top.title("Quiz")
        self.top.protocol("WM_DELETE_WINDOW", self.exit_quiz)

        self.terms = terms[:]
        random.shuffle(self.terms)
        self.index = 0
        self.score = 0

        self.question_label = tk.Label(self.top, text="", font=("Arial", 14), wraplength=500, justify="left")
        self.question_label.pack(pady=10)

        self.var = tk.StringVar()
        self.options = []
        for _ in range(4):
            rb = ttk.Radiobutton(self.top, text="", variable=self.var, value="", style="Quiz.TRadiobutton")
            rb.pack(anchor="w", padx=20, pady=2)
            self.options.append(rb)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(pady=10)

        self.submit_btn = ttk.Button(btn_frame, text="Submit", command=self.check_answer)
        self.submit_btn.pack(side=tk.LEFT, padx=5)

        self.next_btn = ttk.Button(btn_frame, text="Next", command=self.next_question)
        self.next_btn.pack(side=tk.LEFT, padx=5)
        self.next_btn.config(state="disabled")

        self.exit_btn = ttk.Button(btn_frame, text="Exit Quiz", command=self.exit_quiz)
        self.exit_btn.pack(side=tk.LEFT, padx=5)

        self.next_question()

    def next_question(self):
        self.reset_option_styles()
        if self.index >= len(self.terms):
            self.top.destroy()
            return

        self.current_term, self.correct_def = self.terms[self.index]
        self.question_label.config(text=f"What is the definition of:\n\n**{self.current_term}**")

        all_defs = [defn for _, defn in self.terms if defn != self.correct_def]
        choices = random.sample(all_defs, min(3, len(all_defs))) + [self.correct_def]
        random.shuffle(choices)

        self.var.set(None)
        for rb, choice in zip(self.options, choices):
            rb.config(text=choice, value=choice, state="normal", style="Quiz.TRadiobutton")

        self.submit_btn.config(state="normal")
        self.next_btn.config(state="disabled")

        self.index += 1

    def check_answer(self):
        selected = self.var.get()
        if not selected:
            messagebox.showwarning("Select an answer", "Please select an answer before submitting.")
            return

        # Disable all options
        for rb in self.options:
            rb.config(state="disabled")

        # Highlight correct answer green and selected wrong answer red if any
        for rb in self.options:
            if rb.cget("value") == self.correct_def:
                rb.config(style="Correct.TRadiobutton")
            elif rb.cget("value") == selected and selected != self.correct_def:
                rb.config(style="Incorrect.TRadiobutton")

        if selected == self.correct_def:
            self.score += 1

        self.submit_btn.config(state="disabled")
        self.next_btn.config(state="normal")

    def reset_option_styles(self):
        for rb in self.options:
            rb.config(style="Quiz.TRadiobutton")

    def exit_quiz(self):
        if messagebox.askyesno("Exit Quiz", "Are you sure you want to exit the quiz?"):
            self.top.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    app = VocabApp(root)
    root.mainloop()
